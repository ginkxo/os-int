#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <libgen.h>
#include <math.h>
#include "ext2.h"

unsigned char * disk;

#define SINGLE_POINTER_COUNT 12
#define DISK_SECTOR 512

typedef struct {

	int flags[2];

} duoflag;

int goodPath(char * basePath) {

	// SOMETHING TO CHANGE FOR LATER:
	// MAKE SURE ALL INODE NUMBERS ARE IN FACT INODE NUMBERS - 1 WHEN GOING BETWEEN INODES

	// returns:
	// -2 if: already an entry with the same name (EEXIST)
	// -1 if: the pathname does not exist (ENOENT)
	// -1 
	// inodeID -> need to make sure that this is the actual id, not the name

	// struct ext2_super_block * superBlock = (struct ext2_super_block *)(disk + EXT2_BLOCK_SIZE * 1);

	struct ext2_group_desc * blockGp = (struct ext2_group_desc *)(disk + EXT2_BLOCK_SIZE * 2);
	unsigned char * inodeTable = (unsigned char *)(disk + EXT2_BLOCK_SIZE * blockGp->bg_inode_table);

	int inodeID = EXT2_ROOT_INO - 1;

	int basePathLen = strlen(basePath);
	char basepath[basePathLen+1];
	memset(basepath, 0, sizeof(basepath));
	strncpy(basepath, basePath, basePathLen+1);

	char * directoryToCreateConstant = basename(basepath);
	char * pathnameConstant = dirname(basepath);

	int lenpathname = strlen(pathnameConstant);

	char dirToCreate[EXT2_NAME_LEN+1];
	char pathname[lenpathname+1];

	memset(dirToCreate, 0, sizeof(dirToCreate));
	memset(pathname, 0, sizeof(pathname));

	strncpy(dirToCreate, directoryToCreateConstant, EXT2_NAME_LEN+1);
	strncpy(pathname, pathnameConstant, lenpathname+1);

	char * parentDir;
	char * childDir;

	parentDir = strtok(pathname, "/");
	childDir = strtok(NULL, "/");

	char dotRef[EXT2_NAME_LEN] = ".";

	
	while (parentDir != NULL && inodeID != -1) {

		if (strncmp(parentDir, dotRef, lenpathname) == 0 && childDir == NULL) {
			// this is the directory in which we have to create what is currently the parent
			// have to check that the name of the parentDir isn't identical to any entries here!

			struct ext2_inode * rootInode = (struct ext2_inode *)(inodeTable + inodeID * sizeof(struct ext2_inode));

			int numBlocks = rootInode->i_blocks / DSR; 
			int blocknum;

			for (blocknum = 0; blocknum < numBlocks; blocknum++) {

				int rootEntBlock = rootInode->i_block[blocknum];
				int rootEntBlockIterator = 0;

				while (rootEntBlockIterator < EXT2_BLOCK_SIZE) {
					
					struct ext2_dir_entry * dirEntry = (struct ext2_dir_entry *)(disk + EXT2_BLOCK_SIZE * rootEntBlock + rootEntBlockIterator);

					char * dirEntryName = dirEntry->name;
					
					if (strncmp(dirToCreate, dirEntryName, EXT2_NAME_LEN) == 0) {
						// ALREADYIN HERE
						return -2; // FIX for error stuff 
					}

					rootEntBlockIterator = rootEntBlockIterator + dirEntry->rec_len;
					
				}

			}

			
			// we are good to go for trying to create the directory here. return the inode number

			return EXT2_ROOT_INO - 1;
		}

		struct ext2_inode * directoryInode = (struct ext2_inode *)(inodeTable + inodeID * sizeof(struct ext2_inode));

		// need to iterate through entries in directoryInode 

		int directoryExists = 0;
		int newInodeID = -1;
		int numbks = directoryInode->i_blocks / DSR;
		int curr;

		for (curr = 0; curr < numbks; curr++) {

			int directoryEntryBlock = directoryInode->i_block[curr];
			int dirEntBlockIterator = 0;

		// ADDTHE FOR LOOP HERE LATER 

			while (dirEntBlockIterator < EXT2_BLOCK_SIZE) {
		
				struct ext2_dir_entry * directoryEntry = (struct ext2_dir_entry *)(disk + EXT2_BLOCK_SIZE * directoryEntryBlock + dirEntBlockIterator);
			
				char * dirEntName = directoryEntry->name;
				int dirEntInodeID = directoryEntry->inode - 1;

				if (strncmp(parentDir, dirEntName, lenpathname) == 0) {
				// THE NAME of the current looked directory is in this directory!

					if (directoryEntry->file_type == EXT2_FT_REG_FILE) {
					// ERROR : NAME OF FLE
						return -2; // FIX LATER
					} else if (directoryEntry->file_type == EXT2_FT_DIR) {
						directoryExists = 1;
						newInodeID = dirEntInodeID;
						break;
					}

				}

				dirEntBlockIterator = dirEntBlockIterator + directoryEntry->rec_len;

			} // CLOSES dirEntBlockIterator while loop

			if (newInodeID != -1) {
				break;
			}

		}

		if ((!directoryExists) || newInodeID == -1) {
			// pathname is not linked
			// ERROR
			return -1;
		} else {

			parentDir = childDir;
			childDir = strtok(NULL,"/");
			inodeID = newInodeID;
			directoryExists = 0;
			
		}


	} // CLOSES inodeID while loop

	// FINALLY, NEED TO CHECK THE LAST DIRECTORY.
	// this is stored in inodeID.

	struct ext2_inode * finalDirectoryInode = (struct ext2_inode *)(inodeTable + inodeID * sizeof(struct ext2_inode));

	int numblocksFinalDir = finalDirectoryInode->i_blocks / DSR;
	int currblock;

	for (currblock = 0; currblock < numblocksFinalDir; currblock++) {
		
		int finalEntBlock = finalDirectoryInode->i_block[currblock];
		int finalEntBlockIterator = 0;

		while (finalEntBlockIterator < EXT2_BLOCK_SIZE) {

			struct ext2_dir_entry * currDirEntry = (struct ext2_dir_entry *)(disk + EXT2_BLOCK_SIZE * finalEntBlock + finalEntBlockIterator);

			char * currDirEntName = currDirEntry->name;

			if (strncmp(dirToCreate, currDirEntName, EXT2_NAME_LEN) == 0) {

				// ALREADY SOMETHING WITH THE SAME NAME, RETURN ERROR	
				return -2; // FIX LATER I GUESS

			}

			finalEntBlockIterator = finalEntBlockIterator + currDirEntry->rec_len;

		}

	}
	
	return inodeID; // path is valid?

	// we might need to return something about which inode to make or something ...

}

void link(char * path1, char * path2, int isSoft) {

	int pathLen1 = strlen(path1);
	char pathname1[pathLen+1];
	memset(pathname1, 0, sizeof(pathname1));
	strncpy(pathname1, path1, pathLen1+1);

	if (pathname1[pathLen1-1] == '/') {
		pathname1[pathLen1-1] = 0;
	}

	if (pathname1[0] == '/') {
		memmove(pathname1, pathname1+1, pathLen1);
	}

	int pathLen2 = strlen(path2);
	char pathname2[pathLen2+1];
	memset(pathname2, 0, sizeof(pathname2));
	strncpy(pathname2, path2, pathLen2+1);

	if (pathname2[pathLen2-1] == '/') {
		pathname2[pathLen2-1] = 0;
	}

	if (pathname2[0] == '/') {
		memmove(pathname2, pathname2+1, pathLen2);
	}

	// need to make sure both paths are valid




}

int DSR = EXT2_BLOCK_SIZE / DISK_SECTOR; // disk sector ratio
int main(int argc, char ** argv) {

    if(argc <= 4) {
        fprintf(stderr, "Usage: %s <image file name> <absolute path>\n", argv[0]);
        exit(1);
    }
    int fd = open(argv[1], O_RDWR);

    disk = mmap(NULL, 128 * 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if(disk == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    char flagcheck[5] = "-s";

	if (argc == 5 && strncmp(argv[2], "-s", strlen(argv[2])+1) == 0) {

		link(argv[3], argv[4], 1);

	} else {

		link(argv[2], argv[3], 0);
	}

	return 0;
}